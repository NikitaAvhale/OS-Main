Slip 2
Q.1Create a child process using fork(),display parent and child process id. Child process will display the message *HelloWorld" and the parent process should display "Hi". [10marks]
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid;

   
    pid = fork();

    if (pid < 0) {
       
        printf("Fork failed!\n");
        return 1;
    }
    else if (pid == 0) {
        
        printf("Child Process ID: %d\n", getpid());
        printf("Parent Process ID: %d\n", getppid());
        printf("Hello World\n");
    }
    else {
    
        printf("Parent Process ID: %d\n", getpid());
        printf("Child Process ID: %d\n", pid);
        printf("Hi\n");
    }

    return 0;
}
Q.2 Write the simulation program using SJF (non-preemptive). The arrival time and first CPU bursts ofdifferent jobsshould be input to the system. Assume the fixed I/Owaiting time (2 units). The next CPU burst should be generated using random function. The output should give the Gantt chart, Turnaround Time and Waiting time for each process and average times.[20 marks]
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define MAX 100

typedef struct {
    int pid;
    int arrival;
    int burst1;
    int burst2;
    int start;
    int completion;
    int turnaround;
    int waiting;
    bool completed;
} Process;

void sortByBurst(Process p[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = i+1; j < n; j++) {
            if (p[i].burst1 > p[j].burst1) {
                Process temp = p[i];
                p[i] = p[j];
                p[j] = temp;
            }
        }
    }
}

int main() {
    int n, time = 0, completed = 0;
    Process p[MAX];
    int gantt[MAX], gantt_time[MAX], g_index = 0;
    const int io_wait = 2;

    srand(time(NULL)); // Seed for random burst2

    printf("Enter number of processes: ");
    scanf("%d", &n);

    // Input arrival and burst1
    for (int i = 0; i < n; i++) {
        p[i].pid = i;
        printf("Arrival time for P%d: ", i);
        scanf("%d", &p[i].arrival);
        printf("First CPU burst for P%d: ", i);
        scanf("%d", &p[i].burst1);
        p[i].burst2 = rand() % 10 + 1; // Random burst2 between 1 and 10
        p[i].completed = false;
    }

    while (completed < n) {
        int idx = -1;
        int min_burst = 1e9;

        // Find process with shortest burst1 that's arrived
        for (int i = 0; i < n; i++) {
            if (!p[i].completed && p[i].arrival <= time && p[i].burst1 < min_burst) {
                min_burst = p[i].burst1;
                idx = i;
            }
        }

        if (idx != -1) {
            p[idx].start = time;
            gantt[g_index] = p[idx].pid;
            gantt_time[g_index++] = time;

            time += p[idx].burst1 + io_wait + p[idx].burst2;
            p[idx].completion = time;
            p[idx].turnaround = p[idx].completion - p[idx].arrival;
            p[idx].waiting = p[idx].turnaround - (p[idx].burst1 + p[idx].burst2 + io_wait);
            p[idx].completed = true;
            completed++;
        } else {
            time++; // Idle time
        }
    }

    // Gantt Chart
    printf("\nðŸ“Š Gantt Chart:\n");
    for (int i = 0; i < g_index; i++) {
        printf("| P%d @ %d ", gantt[i], gantt_time[i]);
    }
    printf("|\n");

    // Results
    float total_tat = 0, total_wt = 0;
    printf("\nðŸ§® Process Details:\n");
    printf("PID\tArrival\tBurst1\tBurst2\tCT\tTAT\tWT\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].arrival, p[i].burst1, p[i].burst2,
               p[i].completion, p[i].turnaround, p[i].waiting);
        total_tat += p[i].turnaround;
        total_wt += p[i].waiting;
    }

    printf("\nðŸ“ˆ Average Turnaround Time: %.2f\n", total_tat / n);
    printf("ðŸ“‰ Average Waiting Time: %.2f\n", total_wt / n);

    return 0;
}
