Slip 3
Q. 1Creating a child process using the command exec().Note down process ids ofthe parent and the child processes, check whether the control is given back to the parent after the child process terminates 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    printf("Parent Process: PID = %d\n", getpid());

    pid = fork();  // Create child process

    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    }
    else if (pid == 0) {
        // Child process
        printf("Child Process: PID = %d, Parent PID = %d\n", getpid(), getppid());

        // Replace child process with another program (e.g., "ls")
        execl("/bin/ls", "ls", NULL);

        // If exec fails
        perror("Exec failed");
        exit(1);
    }
    else {
        // Parent process
        wait(NULL);  // Wait for child to finish
        printf("Child process terminated. Control returned to parent (PID = %d).\n", getpid());
    }

    return 0;
}
Q.2 Writethe simulation program using FCFS. The arrival time and first CPU bursts of different jobs should be input to the system. Assume the fixed /Owaiting time (2units). The next CPU burst should be generated using random function. The output should givethe Gantt chart, Turnaround Time and Waiting time for each process and average times. [20marks]
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define MAX 100

typedef struct {
    int pid;
    int arrival;
    int burst1;
    int burst2;
    int start;
    int completion;
    int turnaround;
    int waiting;
} Process;

void sortByArrival(Process p[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = i+1; j < n; j++) {
            if (p[i].arrival > p[j].arrival) {
                Process temp = p[i];
                p[i] = p[j];
                p[j] = temp;
            }
        }
    }
}

int main() {
    int n, time = 0;
    Process p[MAX];
    int gantt[MAX], gantt_time[MAX], g_index = 0;
    const int io_wait = 2;

    srand(time(NULL)); // Seed for random burst2

    printf("Enter number of processes: ");
    scanf("%d", &n);

    // Input arrival and burst1
    for (int i = 0; i < n; i++) {
        p[i].pid = i;
        printf("Arrival time for P%d: ", i);
        scanf("%d", &p[i].arrival);
        printf("First CPU burst for P%d: ", i);
        scanf("%d", &p[i].burst1);
        p[i].burst2 = rand() % 10 + 1; // Random burst2 between 1 and 10
    }

    // Sort by arrival time
    sortByArrival(p, n);
for (int i = 0; i < n; i++) {
        if (time < p[i].arrival) {
            time = p[i].arrival; // CPU idle until process arrives
        }
p[i].start = time;
        gantt[g_index] = p[i].pid;
        gantt_time[g_index++] = time;
 time += p[i].burst1 + io_wait + p[i].burst2;
        p[i].completion = time;
        p[i].turnaround = p[i].completion - p[i].arrival;
        p[i].waiting = p[i].turnaround - (p[i].burst1 + p[i].burst2 + io_wait);
    }
printf("\nðŸ“Š Gantt Chart:\n");
    for (int i = 0; i < g_index; i++) {
        printf("| P%d @ %d ", gantt[i], gantt_time[i]);
    }
    printf("|\n");
float total_tat = 0, total_wt = 0;
    printf("\nðŸ§® Process Details:\n");
    printf("PID\tArrival\tBurst1\tBurst2\tCT\tTAT\tWT\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].arrival, p[i].burst1, p[i].burst2,
               p[i].completion, p[i].turnaround, p[i].waiting);
        total_tat += p[i].turnaround;
        total_wt += p[i].waiting;
    }

    printf("\nðŸ“ˆ Average Turnaround Time: %.2f\n", total_tat / n);
    printf("ðŸ“‰ Average Waiting Time: %.2f\n", total_wt / n);
  return 0;
}
